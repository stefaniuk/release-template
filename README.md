# Dev to Prod Fast Release

This repository demonstrates a fully automated release workflow that moves code from development to production safely and transparently, using [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/), [Semantic Versioning](https://semver.org/), and signed releases. The goal is to show how teams can automate versioning, tagging, and release publication, all without manual intervention or risk of inconsistency.

- [Dev to Prod Fast Release](#dev-to-prod-fast-release)
  - [Overview](#overview)
  - [Structure](#structure)
    - [Repository files](#repository-files)
    - [Plugins flow](#plugins-flow)
    - [Configuration](#configuration)
      - [Variables](#variables)
      - [Secrets](#secrets)
  - [Prerequisites](#prerequisites)
    - [GitHub App setup](#github-app-setup)
    - [User bot setup](#user-bot-setup)
  - [Design decisions and rationale](#design-decisions-and-rationale)
    - [üß© Why use a GitHub App Token instead of a Personal Access Token (PAT)](#-why-use-a-github-app-token-instead-of-a-personal-access-token-pat)
    - [üîê Why the signing key belongs to a bot, not the App](#-why-the-signing-key-belongs-to-a-bot-not-the-app)
    - [üîè Why we don't force tag signing by default](#-why-we-dont-force-tag-signing-by-default)
    - [üìò Why we don't commit a `CHANGELOG.md`](#-why-we-dont-commit-a-changelogmd)
    - [üê≥ Use a flat registry for multiple images](#-use-a-flat-registry-for-multiple-images)
  - [How to use this repository](#how-to-use-this-repository)
    - [Adding a new feature](#adding-a-new-feature)
    - [How Conventional Commits affect versioning](#how-conventional-commits-affect-versioning)

## Overview

On every push or merged Pull Request to main, the workflow [`.github/workflows/cicd-2-publish.yaml`](.github/workflows/cicd-2-publish.yaml)
automatically:

1. Generates a short-lived GitHub App token for authenticated commits and releases
2. Analyses commit messages following Conventional Commits
3. Determines the next Semantic Version
4. Writes the version to `VERSION` and commits it with a signed message
5. Creates a Git tag, e.g. `v1.2.3`
6. Publishes a GitHub Release with autogenerated notes using the App token
7. Logs in to GitHub Container Registry (GHCR) using the default `GITHUB_TOKEN`
8. Builds and pushes a container image tagged with the new version (e.g. `ghcr.io/org/repo:app-1.2.3`)

As an effect of it every release is predictable, traceable, and fully automated.

## Structure

### Repository files

| File                                    | Purpose                                                                                                       |
| --------------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| `.github/workflows/cicd-2-publish.yaml` | The GitHub Actions workflow that orchestrates authentication, key import, and the semantic-release execution. |
| `.releaserc`                            | Defines how semantic-release runs, which plugins are used, and how each stage behaves.                        |
| `VERSION`                               | A plain-text file containing the current version, updated automatically during each release.                  |

### Plugins flow

Order in `.releaserc`:

Semantic-release works as a modular pipeline. In this configuration, the stages run in this order:

1. `@semantic-release/commit-analyzer` reads commits to decide whether to bump the major, minor, or patch version
2. `@semantic-release/release-notes-generator` converts commit history into human-readable release notes
3. `@semantic-release/exec` writes the new version string (${nextRelease.version}) into the VERSION file
4. `@semantic-release/git` commits that change with a consistent message such as chore(release): 1.2.0 [skip ci]
5. `@semantic-release/github` publishes a GitHub Release entry with the generated notes

The process ensures that version bumps, tags, and release notes are always consistent with your commit history.

### Configuration

#### Variables

Repository variables define the static configuration needed by the workflow:

- `GH_APP_ID` - numeric ID of the GitHub App
- `GIT_SIGN_BOT_NAME` - the display name used for the bot's signed commits
- `GIT_SIGN_BOT_EMAIL` - the bot's email address (must match the uploaded GPG key)

#### Secrets

Repository secrets provide the credentials and cryptographic materials required to sign releases:

- `GH_APP_PRIVATE_KEY` - the GitHub App's private PEM key (used for authentication)
- `GIT_SIGN_BOT_GPG_PRIVATE_KEY` - the ASCII-armoured private GPG key of the signing bot
- `GIT_SIGN_BOT_GPG_PASSPHRASE` - the GPG key passphrase

## Prerequisites

### GitHub App setup

Follow these steps to create and configure a minimal‚Äëpermission GitHub App that will authenticate the release workflow. This should be done for you by the NHS GitHub Admins. You can perform this setup yourself for testing..

1. Create the App

   - Go to [GitHub App settings](https://github.com/settings/apps) user _Settings ‚Üí Developer Settings ‚Üí GitHub Apps ‚Üí New GitHub App_
   - Name it something like _"My Dev to Prod Fast Release App"_ (must be globally unique)
   - Set the homepage URL to your repository
   - Configure permissions
     - Repository permissions:
       - _Contents: Read & write_, needed to create tags and commit `VERSION`
       - _Issues: Read & write_, enables adding release notes comments
       - _Pull requests: Read & write_, allows future PR commenting automation
       - All other repository permissions: No access
     - _Organization permissions: None required_
     - _Account permissions: None required_
   - For the installation scope choose _Only on this account_ (or organisation-wide if required)

2. Generate the private key

   - After saving, click _Generate a private key_
   - Copy the full `.pem` file contents (including BEGIN/END lines)
   - Store it securely, you'll need it to populate `GH_APP_PRIVATE_KEY`

3. Install the App

   - Click _Install App_ on the App page
   - Choose your user account
   - Select _Only select repositories_ ‚Üí pick this repository (recommended) or _All repositories_ (broader scope-only if necessary)

4. Add repository variables & secrets

   - Go to your repository ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions
   - Add the variables and secrets listed above

5. Test

   - Make a trivial commit e.g. `docs: test app token wiring` to `main`
   - In workflow logs confirm the _"Generate GitHub App token"_ step succeeds

   After setup, this step in your workflow will issue short-lived authentication tokens automatically:

   ```yaml
   - name: Generate GitHub App token
   uses: actions/create-github-app-token@v2
   with:
       app-id: ${{ vars.GH_APP_ID }}
       private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}
   ```

### User bot setup

TODO: [Create GPG key](https://github.com/nhs-england-tools/repository-template/blob/main/docs/user-guides/Sign_Git_commits.md)

## Design decisions and rationale

This section captures the thinking behind some key design choices.

### üß© Why use a GitHub App Token instead of a Personal Access Token (PAT)

Using a GitHub App offers significant security and governance advantages:

- Least privilege, the App's installation can be scoped to specific repos with tightly controlled permissions
- Ephemeral credentials, tokens are short-lived and automatically rotated, minimising the impact of leaks
- Easy revocation, uninstalling the App immediately cuts off access, no manual key rotation needed
- Auditability, actions performed by the App are attributed to its installation in GitHub logs
- Operational separation, avoids depending on a human user's PAT, which could carry excessive scopes or expire unexpectedly

In practice, this means safer automation with better traceability and compliance.

### üîê Why the signing key belongs to a bot, not the App

GitHub verifies GPG and SSH signatures against user or bot accounts, not apps. Because of that, the release workflow uses a dedicated bot identity that owns the signing key. The benefits are as follows:

- Commits and tags show the green "Verified" badge, proving authenticity
- Release authorship is clearly separate from individual developers
- Keys can be rotated independently of personal credentials
- Auditing is straightforward, every release is traceable to a single, consistent bot identity

The public key must be uploaded to the GitHub profile of the account listed in `GIT_SIGN_BOT_EMAIL` to ensure signatures validate correctly.

### üîè Why we don't force tag signing by default

Tag signing can be valuable, but it adds complexity in non-interactive CI environments. Here's why it's disabled by default:

- Simplicity, signed annotated tags require a message, without it, Git tries to open an editor and fails in CI
- Reliability, lightweight tags work flawlessly with semantic-release, annotated tags can hang or error if GPG or message handling is misconfigured
- Sufficient provenance, signed commits combined with GitHub Releases already provide a trustworthy audit trail

If you later want to add signed annotated tags, you can do so safely once your workflow is stable, e.g.:

```bash
git tag -a -m "vX.Y.Z" vX.Y.Z && git push --force origin vX.Y.Z
```

### üìò Why we don't commit a `CHANGELOG.md`

Instead of maintaining a growing Markdown changelog, this design treats GitHub Releases as the single source of truth. Each release contains its own autogenerated notes, which are easy to view, compare, or query via API. Advantages are:

- Single source of truth, release notes live where users expect them, in the Releases tab
- Cleaner history, release commits only touch the `VERSION` file, avoiding noisy changelog diffs
- Fewer merge conflicts, no simultaneous changelog edits across branches
- Better performance, no rewriting of a large markdown file every release
- API-friendly, release data is structured and accessible via GitHub's API for dashboards or audits

If an on-disk changelog is ever needed (e.g. for packaged distributions), re-enable `@semantic-release/changelog` or build an export pipeline that generates one on demand.

### üê≥ Use a flat registry for multiple images

When a single repository produces multiple container images (for example, api, ui, or cli), GitHub‚Äôs Container Registry (GHCR) imposes certain structural and permission constraints on how those images can be stored and tagged. Key points and reasoning:

- GitHub App tokens cannot publish to GHCR, app installation tokens do not have package-level permissions for container publishing. To push images, use the built-in `GITHUB_TOKEN` instead, which automatically grants write access to your repository's package namespace
- Registry scope is flat, the `GITHUB_TOKEN` can only push images to the registry path matching the repository's namespace e.g. ghcr.io/owner/repo. Nested namespaces like ghcr.io/owner/repo/api are not permitted when authenticating via `GITHUB_TOKEN`
- Use tag naming to distinguish components, since subpaths are unavailable, encode the component name and version together in the tag. The recommended convention is component-version, for example `ghcr.io/org/repo:api-1.2.3`
- Why this pattern works
  - Flat structure compatible with GHCR permissions and the default `GITHUB_TOKEN`
  - Aligns with common multi-image tagging practices `nginx:alpine-1.25`, `python:3.12-slim`
  - Simple to automate, the same semantic version applies across components
  - Easy to query, filter, and sort by component prefix e.g. `api-*`
- Alternative patterns - other semver-valid formats such as `1.2.3+api` or `api_v1.2.3` were evaluated, but `api-1.2.3` offers the best portability, readability, and compatibility with container image tooling and CI pipelines

TODO:

- Does the first version of the image has to be pushed using PAT to create the namespace? (no, it was created automaticly!) so there are things to ensure:
  - Package registry has to be connected to the repository explicitly in the settings
  - In the _Manage Actions access_ ensure that the repository is on the list
  - Tick _Inherit access from source repository (recommended)_
  - Visability of the package has to match the repository vvisability
- Does it still require App to have Package write permission?
  - Currnet access: Read access to metadata & Read and write access to code, issues, and packages
  - Droped the package registry and expexcted this to still work (re-creaet automaticly)
- `packages: write` (CHECKING) removed package app access -> set to none

---

- ${{ github.token }} or ${{ secrets.GITHUB_TOKEN }}
- Go to your repo ‚Üí Settings ‚Üí Actions ‚Üí General
  - Scroll to Workflow permissions
    Enable:
    ‚úÖ ‚ÄúRead and write permissions‚Äù
    ‚úÖ ‚ÄúAllow GitHub Actions to create and approve pull requests‚Äù

üëÜ which of these?

This _"flat registry with tagged components"_ model scales cleanly across repositories while staying compliant with GitHub's authentication and namespace rules.

## How to use this repository

### Adding a new feature

1. Create a branch and commit changes using Conventional Commits, for example:

   ```plaintext
   feat(ui): add user authentication
   ```

2. Open a Pull Request and merge it into `main`, ensure that the commit created as an effect of merging this PR contains the above message as this drives the semantic versioning
3. The workflow will:

   - Detect that the change type is `feat` ‚Üí trigger a _minor_ version bump
   - Update the `VERSION` file
   - Commit and tag the new release
   - Publish release notes automatically

You'll see the new tag and release appear on GitHub, both signed and verified (commit).

### How Conventional Commits affect versioning

| Type              | Example                                  | Version bump | Explanation                                                                                                 |
| ----------------- | ---------------------------------------- | ------------ | ----------------------------------------------------------------------------------------------------------- |
| `docs`            | `docs(readme): update section`           | no bump      | Documentation-only change, does not affect the application's behaviour or API                               |
| `style`           | `style(css): normalise headings`         | no bump      | Code style or formatting change (e.g. whitespace, lint fixes) - no functional impact                        |
| `chore`           | `chore(release): housekeeping`           | no bump      | Maintenance or tooling updates unrelated to user-facing code                                                |
| `test`            | `test(ci): add smoke tests`              | no bump      | Adds or modifies tests, does not change runtime or API behaviour                                            |
| `refactor`        | `refactor(ci): simplify logic`           | patch        | Code improvement or cleanup without changing behaviour, treated like a small fix                            |
| `perf`            | `perf(core): improve runtime`            | patch        | Performance enhancement without altering external behaviour, treated as a fix                               |
| `fix`             | `fix(ci): correct signing config`        | patch        | Corrects an existing issue, triggers a patch version bump (`x.y.z ‚Üí x.y.(z+1)`)                             |
| `feat`            | `feat(ci): add exec plugin`              | minor        | Introduces a new, backward-compatible feature, triggers a minor version bump (`x.y.z ‚Üí x.(y+1).0`)          |
| `<type>[scope]!:` | `feat(api)!: remove deprecated endpoint` | major        | Introduces a breaking change (non-backward-compatible), triggers a major version bump (`x.y.z ‚Üí (x+1).0.0`) |
